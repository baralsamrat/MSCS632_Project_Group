### [ :arrow_left: ](/src/1/1.md) | [ HOME ](/README.md) | [ :arrow_right: ](/src/3/3.md)

# Group Project - Cross-Language Development - Comparison of Expense Tracker Implementations: C++ vs Python

## Team Contributions

|       NAME        | Email                           | Contributions                                                                                                                       |
| :---------------: | :------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------- |
| Prasanna Adhikari | padhikari34605@ucumberlands.edu | Led the C++ implementation, focusing on memory management with smart pointers and efficient use of STL containers.                  |
|  Shashwat Baral   | sbaral29114@ucumberlands.edu    | Developed the Python implementation, emphasizing the use of dynamic typing and the simplicity of Python’s data structures.          |
|   Samrat Baral    | sbaral29114@ucumberlands.edu    | Implemented the metrics and visualization components, providing side-by-side comparisons of code metrics between the two languages. |
|  Sahithi Bontha   | sbontha35464@ucumberlands.edu   | Coordinated integration, documentation, and testing, ensuring all contributions were reflected in the GitHub repository.            |

#### REPORT : [ - :notebook_with_decorative_cover: PDF ](/reports/2.pdf)

---

## Introduction

This report compares two implementations of an Expense Tracker Application—one in C++ and one in Python. Both versions support the same core functions: adding expenses, filtering expenses by date or category, and displaying expense summaries. However, they leverage language-specific features that have different impacts on design, performance, and readability.

# Screenshot

```bash
chmod +x main.sh
./main.sh
```

- ![Evidence 1](/screenshot/2/Capture-1.png)
- ![Evidence 2](/screenshot/2/Capture-2.png)
- ![Evidence 3](/screenshot/2/Capture-3.png)

---

## Key Language-Specific Features

Below is a table comparing three major language-specific features—memory management, data structures, and error handling/verbosity—with code snippets to showcase the differences between the C++ and Python implementations.

| **Feature**                           | **C++ Implementation**                                                                                                                                                                                                                                            | **Python Implementation**                                                                                                                                                                                                                                                                                |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Memory Management**                 | **Approach:** Uses smart pointers (`std::unique_ptr`) to ensure deterministic memory cleanup.                                                                                                                                                                     | **Approach:** Relies on automatic garbage collection, simplifying the code without manual memory management.                                                                                                                                                                                             |
|                                       | **Code Snippet:**<br>`cpp<br>void addExpense(const std::string &date, double amount, const std::string &category, const std::string &description) {<br>    expenses.push_back(std::make_unique<Expense>(Expense{date, amount, category, description}));<br>}<br>` | **Code Snippet:**<br>`python<br>def add_expense(date, amount, category, description):<br>    expense = {<br>        "date": date,<br>        "amount": amount,<br>        "category": category,<br>        "description": description<br>    }<br>    expenses.append(expense)<br>`                      |
| **Data Structures**                   | **Approach:** Defines a `struct Expense` for type safety and uses STL containers (`std::vector` and `std::map`) for efficient storage and retrieval.                                                                                                              | **Approach:** Uses dynamic data structures like lists and dictionaries, which reduce boilerplate code and enhance readability.                                                                                                                                                                           |
|                                       | **Code Snippet:**<br>`cpp<br>struct Expense {<br>    std::string date;<br>    double amount;<br>    std::string category;<br>    std::string description;<br>};<br><br>std::vector<std::unique_ptr<Expense>> expenses;<br>`                                       | **Code Snippet:**<br>`python<br>expenses = []<br><br>def add_expense(date, amount, category, description):<br>    expense = {<br>        "date": date,<br>        "amount": amount,<br>        "category": category,<br>        "description": description<br>    }<br>    expenses.append(expense)<br>` |
| **Error Handling and Code Verbosity** | **Approach:** C++ requires explicit error handling and type declarations, resulting in more verbose but predictable code.                                                                                                                                         | **Approach:** Python’s concise syntax and exception handling allow for faster prototyping and easier maintenance, though with less control.                                                                                                                                                              |
|                                       | **Discussion:** Explicit type checking and manual error handling help catch issues at compile time.                                                                                                                                                               | **Discussion:** Dynamic typing and built-in exceptions simplify development at the expense of potentially catching errors later (at runtime).                                                                                                                                                            |

## Impact on Design, Performance, and Readability

- **Design:**  
  The C++ implementation’s explicit memory management and static type system demand a disciplined design approach, which can result in highly optimized and robust applications. In contrast, Python’s dynamic typing and high-level abstractions allow for rapid development and simpler designs.

- **Performance:**  
  C++ typically outperforms Python in raw execution speed and resource management due to its low-level control and compile-time optimizations. Python, while generally slower, is more than adequate for applications where rapid development and maintainability are prioritized.

- **Readability:**  
  Python’s concise and expressive syntax makes the code more accessible, particularly for those new to programming. C++ code tends to be more verbose, which can improve clarity around resource management but might be more challenging for quick prototyping.

## Conclusion

Both the C++ and Python implementations of the Expense Tracker meet the core functional requirements, yet each language’s unique features influence the application in different ways. The C++ version benefits from tight control over memory and high performance, while the Python version excels in readability and rapid development. This comparative study underscores the trade-offs inherent in choosing one language over another and demonstrates that both approaches can successfully implement the same core functionality with distinct advantages.

---
